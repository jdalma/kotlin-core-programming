
# **코틀린은 왜 if와 when 식을 도입했을까?**    
(값을 만들 때 사용하는 if를 **if 식**이라고 한다.)    
if/when을 식으로 사용할 수 없으면 조건에 따라 값이 달라지는 경우 반드시 var변수를 사용하고 적당한 초깃값으로 그 변수를 초기화해야만 한다.    

```kotlin
var tmp = ""
if (doSoemthing())
    tmp = "성공"
else
    tmp = "실패"
```

`val` 사용을 편리하게 해주고 더 장려하기 위함이다.  

# **식과 연산자**

**식**  
- 어떤 한 가지 값으로 계산될 수 있는 프로그램 조각을 뜻한다.
- 가장 단순한 식은 값을 표현하는 `리터럴`이며, **식을 서로 엮어서 새로운 식을 만들때는 연산자를 사용**한다.
  - 사칙연산, 나머지연산, 비교연산, 논리연산, 함수호출
- 위에서 본 `if/when`도 식으로 사용할 수 있지만, `try/catch/finally`도 식으로 사용할 수 있다.
- 식을 이루는 연산자에는 **우선순위**와 **결합 방향**이 있다.
  - 코틀린에서 걸합 방향이 오른쪽 우선인 연산자는 `단항 부호 연산자`와 `논리 부정 연산자`뿐이다.
  
**문**
- 값을 만들어내지는 않지만 프로그램의 흐름을 제어하는 역할을 한다.
- 식이 만들어내는 값을 무시하면 식도 문 역할을 할 수 있으며, 이런 경우가 함수를 호출하고 결괏값을 사용하지 않는 경우다.
  - 이 경우는 결괏값을 돌려받아 사용하기 보다는 어떤 공유된 상태를 변경하거나 입출력을 수행하는 함수는 **사용자가 정의한 문**역할을 한다고 볼 수 있다.
- `val/var`을 선언하는 문장이나 함수, 클래스, 객체를 선언하는 문장, `if/when`문, 대입문이나 복합 대입문(+=, -=, *=, /=), 루프문, `try/catch`등이 코틀린에 사용되는 문장들이다.

# **람다식**

- **배열 생성자에 람다식 전달하기**
  - 람다식의 `it`에는 채워 넣을 객체의 인덱스가 자동으로 전달된다.

```kotlin
/**
 * init 함수는 첫 번째 배열 요소부터 순차적으로 시작하여 각 배열 요소에 대해 호출됩니다. 인덱스가 지정된 배열 요소의 값을 반환해야 합니다.
 **/
public inline constructor(size: Int, init: (Int) -> T)

val arrayOf1To10 = Array(10) {it + 1}
```

# **코틀린에서의 원시 타입은?**

- 자바의 원시 타입들은 메모리 상에서 해당 타입의 값을 표현하는 2진수 값으로 존재하고, 멤버 함수 호출이 가능한 객체로 존재하지 않는다.
- 하지만 **코틀린에서는 모든 대상을 객체처럼 취급할 수 있으며, 문맥에 따라 컴파일러가 알아서 원시 타입 값으로 처리하거나 객체로 처리해준다.**
- 이때, **`Array<Int>` 타입의 배열을 생성할 때는 원시 타입의 32비트 정수 값만 저장될지 보장할 수 없다.**
  - 이런 경우 컴파일러는 안전한 방식으로 배열의 원소들을 32비트 정수 값이 아니라 **정수 값 객체를 가리키는 참조를 사용할 수 밖에 없는 참조 배열을 사용한다.**
  - 원시 타입으로 쓸 것이 명확하다면 원시 배열의 `{Type}Array` 클래스들이 존재한다.
- [추가 내용 - kotlinlang 기본타입](https://kotlinlang.org/docs/basic-types.html)

# **익명 함수와 람다** 📌

- 익명 함수는 이름이 없는 함수 이며, 코틀린 람다는 익명 함수와 비슷하지만 좀 더 간결한 문법을 제공한다.
- **익명 함수와 람다 모두 함수 역할을 할 수 있는 값을 정의하는 `리터럴`이다.**
- 따라서 다른 타입의 리터럴과 마찬가지로 **값이나 식이 쓰일 수 있는 위치에 사용할 수 있다.**
- **람다는 항상 본문이 `식`인 형태로만 정의해야 하며, `return`을 쓸 수 없고 맨 마지막에 쓴 식의 값이 전체 값이 된다.**
- 람다는 일반적인 값과 마찬가지로 쓰일 수 있다. 
- 람다를 **데이터 구조에 저장하거나, 함수의 인자로 전달하거나, 함수에서 생성해 반환할 수 있다.** 이와 같은 성질을 **<span style="background-color:#FFE6E6">일급 시민</span>으로 취급한다.** 라고 말하며, 
- 람다를 **파라미터로 받거나 람다를 반환하는 함수를 <span style="background-color:#FFE6E6">고차 함수</span>** 라고 부른다.

```kotlin
fun andThen(
    f: (Int) -> Int,
    g: (Int) -> Int
) : (Int) -> Int = {
    value: Int -> g(f(value))
}

val called = andThen(
    { x: Int -> x + 2 },
    { x: Int -> x * x }
)(4)
```

`andThen()`의 결과 타입은 `(Int) -> Int`이다.  
Int 하나를 파라미터로 받아서 Int 타입의 결과를 내어주는 함수이다.  
`andThen` 함수의 파라미터 람다 2개로 `value`의 값을 가공하는 것인데, `value`는 `andThen`의 리턴 람다의 파라미터이다. 📌  

**컴파일러가 익명 함수나 람다의 타입을 명확히 알 수 있는 경우, 파라미터 타입을 생략해도 좋다.**  
- 익명 함수에서는 반환 타입을 지정해주지 않으면 `Unit`으로 해석한다.
그리고 람다 파라미터가 하나일 경우 `it`키워드를 사용하여 파라미터를 사용할 수 있다.  

## **클로저와 값 포획**

람다나 익명 함수도 구문적 영역 규칙을 통해 찾을 수 있는 이름을 자유롭게 사용할 수 있다.  
하지만 함수가 다른 함수를 반환하는 **고차 함수**라면 복잡한 문제가 생길 수 있다. 📌  
**고차 함수가 반환하는 `람다의 수명이 고차 함수가 실행되고 반환되는 시점 이후에도 계속 될 수 있기 때문`이다.**  
  
[클로저 예제](https://github.com/jdalma/kotlin-core-programming/commit/d6972ef64c43925fba43f35aa87e6c5c7ad524c4)에서 `state` 함수의 내부 `memory` 변수는 반환되는 `func`에 의해 참조당해야 하기 때문에 **힙 영역**에 따로 저장된다.  
이와 같이 **람다 코드와 더불어 람다를 계산할 때 필요한 모든 환경을 갖춰서 일종의 닫힌 식을 만들어주는 이런 구조를 `클로저`라고 부른다.**  
- 클로저라는 말을 익명 함수나 람다와의 동의어로 여기는 사람도 있다.
  
람다나 함수 내부에 정의되지 않은 바깥 영역에서 정의를 찾아야 하는 변수를 **자유 변수**라고 하며, 외부 영역의 변수를 클로저에 붙들게 되는 현상을 **포획**이라 한다.  
기억이 잘 나지 않는다면 [고차함수 예제](https://github.com/jdalma/kotlin-core-programming/commit/0417b9c1fc1d40ad01b8fb11871bcca57e10d2f5)를 확인하자.  
  
> 함수가 상태를 계속 유지할 수 있다는 것이 신기하다. 이 람다의 참조가 유지되는 한 상태는 계속 유지되겠지?  
> 그리고 람다 밖의 변수도 참조가 유지되어야 하기 때문에 힙 영역에 저장하는것도 신기하다.
