
# **코틀린은 왜 if와 when 식을 도입했을까?**    
(값을 만들 때 사용하는 if를 **if 식**이라고 한다.)    
if/when을 식으로 사용할 수 없으면 조건에 따라 값이 달라지는 경우 반드시 var변수를 사용하고 적당한 초깃값으로 그 변수를 초기화해야만 한다.    

```kotlin
var tmp = ""
if (doSoemthing())
    tmp = "성공"
else
    tmp = "실패"
```

`val` 사용을 편리하게 해주고 더 장려하기 위함이다.  

# **식과 연산자**

**식**  
- 어떤 한 가지 값으로 계산될 수 있는 프로그램 조각을 뜻한다.
- 가장 단순한 식은 값을 표현하는 `리터럴`이며, **식을 서로 엮어서 새로운 식을 만들때는 연산자를 사용**한다.
  - 사칙연산, 나머지연산, 비교연산, 논리연산, 함수호출
- 위에서 본 `if/when`도 식으로 사용할 수 있지만, `try/catch/finally`도 식으로 사용할 수 있다.
- 식을 이루는 연산자에는 **우선순위**와 **결합 방향**이 있다.
  - 코틀린에서 걸합 방향이 오른쪽 우선인 연산자는 `단항 부호 연산자`와 `논리 부정 연산자`뿐이다.
  
**문**
- 값을 만들어내지는 않지만 프로그램의 흐름을 제어하는 역할을 한다.
- 식이 만들어내는 값을 무시하면 식도 문 역할을 할 수 있으며, 이런 경우가 함수를 호출하고 결괏값을 사용하지 않는 경우다.
  - 이 경우는 결괏값을 돌려받아 사용하기 보다는 어떤 공유된 상태를 변경하거나 입출력을 수행하는 함수는 **사용자가 정의한 문**역할을 한다고 볼 수 있다.
- `val/var`을 선언하는 문장이나 함수, 클래스, 객체를 선언하는 문장, `if/when`문, 대입문이나 복합 대입문(+=, -=, *=, /=), 루프문, `try/catch`등이 코틀린에 사용되는 문장들이다.

# **람다식**

- **배열 생성자에 람다식 전달하기**
  - 람다식의 `it`에는 채워 넣을 객체의 인덱스가 자동으로 전달된다.

```kotlin
/**
 * init 함수는 첫 번째 배열 요소부터 순차적으로 시작하여 각 배열 요소에 대해 호출됩니다. 인덱스가 지정된 배열 요소의 값을 반환해야 합니다.
 **/
public inline constructor(size: Int, init: (Int) -> T)

val arrayOf1To10 = Array(10) {it + 1}
```

# **코틀린에서의 원시 타입은?**

- 자바의 원시 타입들은 메모리 상에서 해당 타입의 값을 표현하는 2진수 값으로 존재하고, 멤버 함수 호출이 가능한 객체로 존재하지 않는다.
- 하지만 **코틀린에서는 모든 대상을 객체처럼 취급할 수 있으며, 문맥에 따라 컴파일러가 알아서 원시 타입 값으로 처리하거나 객체로 처리해준다.**
- 이때, **`Array<Int>` 타입의 배열을 생성할 때는 원시 타입의 32비트 정수 값만 저장될지 보장할 수 없다.**
  - 이런 경우 컴파일러는 안전한 방식으로 배열의 원소들을 32비트 정수 값이 아니라 **정수 값 객체를 가리키는 참조를 사용할 수 밖에 없는 참조 배열을 사용한다.**
  - 원시 타입으로 쓸 것이 명확하다면 원시 배열의 `{Type}Array` 클래스들이 존재한다.
- [추가 내용 - kotlinlang 기본타입](https://kotlinlang.org/docs/basic-types.html)
